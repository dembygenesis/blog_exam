package mysql

import (
	"database/sql"
	"github.com/DATA-DOG/go-sqlmock"
	"github.com/dembygenesis/blog_exam/pkg/models"
	"github.com/dembygenesis/blog_exam/pkg/models_autogenerated"
	"github.com/friendsofgo/errors"
	"github.com/stretchr/testify/assert"
	"testing"
)

// TestArticle_Read test read method
func TestArticle_Read(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Errorf("failed to init sqlmock: %v", err)
		return
	}

	type fields struct {
		conn *sql.DB
	}

	type args struct {
		id int
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantArticles  *models_autogenerated.ArticleSlice
		wantErr bool
	}{
		{
			name: "Test Read Fail",
			fields: fields{conn: db},
			args: args{id: 0},
			wantArticles: nil,
			wantErr: false,
		},
		{
			name: "Test Read All",
			fields: fields{conn: db},
			args: args{id: 0},
			wantArticles: &models_autogenerated.ArticleSlice{
				&models_autogenerated.Article{
					ID:      1,
					Title:   "Exists",
					Content: "Once upon a time, Alohamora!",
					Author:  "J.K Rowling",
				},
			},
			wantErr: false,
		},
		{
			name: "Test Read One",
			fields: fields{conn: db},
			args: args{id: 1},
			wantArticles: &models_autogenerated.ArticleSlice{
				&models_autogenerated.Article{
					ID:      1,
					Title:   "Exists",
					Content: "Once upon a time, Alohamora!",
					Author:  "J.K Rowling",
				},
			},
			wantErr: false,
		},
	}

	for _, test := range tests {
		store := Article{conn: test.fields.conn}

		if test.name == "Test Read Fail" {
			mock.ExpectQuery("SELECT (.+) FROM `article`.*").WillReturnError(errors.New("error trying to fetch the articles"))
			_, err = store.Read(test.args.id)
			assert.EqualError(t, err, "error trying to fetch the articles", "failed at: \"%v\"", test.name)
		}

		if test.name == "Test Read All" {
			row := sqlmock.NewRows([]string{"id", "title", "content", "author"}).
				AddRow(1, "Exists", "Once upon a time, Alohamora!", "J.K Rowling")
			mock.ExpectQuery("SELECT (.+) FROM `article` WHERE .*").WillReturnRows(row)
			res, err := store.Read(test.args.id)
			if err != nil {
				assert.EqualErrorf(t, err, "error trying to fetch the articles", "failed at: \"%v\"", test.name)
			}
			assert.Equalf(t, res, test.wantArticles, "failed at: \"%v\"", test.name)
		}

		if test.name == "Test Read One" {
			row := sqlmock.NewRows([]string{"id", "title", "content", "author"}).
				AddRow(1, "Exists", "Once upon a time, Alohamora!", "J.K Rowling")
			mock.ExpectQuery("SELECT (.+) FROM `article` WHERE .*").WillReturnRows(row)
			res, err := store.Read(test.args.id)
			if err != nil {
				assert.EqualErrorf(t, err, "error trying to fetch the articles", "failed at: \"%v\"", test.name)
			}
			assert.Equalf(t, res, test.wantArticles, "failed at: \"%v\"", test.name)
			assert.Equalf(t, test.args.id, (*test.wantArticles)[0].ID, "failed at: \"%v\"", test.name)
		}
	}
}

// TestArticle_Create test create method
func TestArticle_Create(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Errorf("failed to init sqlmock: %v", err)
		return
	}

	type fields struct {
		conn *sql.DB
	}

	type args struct {
		article models.Article
	}

	tests := []struct {
		name    string
		fields  fields
		args    args
		wantID  int
		wantErr bool
	}{
		{
			name: "Test query error",
			fields: fields{
				conn: db,
			},
			args: args{article: models.Article{
				Title:   "Harry Potter",
				Content: "Once upon a time, Alohamora!",
				Author:  "J.K Rowling",
			}},
			wantID:  0,
			wantErr: true,
		},
		{
			name: "Test unique",
			fields: fields{
				conn: db,
			},
			args: args{article: models.Article{
				Title:   "Exists",
				Content: "Once upon a time, Alohamora!",
				Author:  "J.K Rowling",
			}},
			wantID:  0,
			wantErr: true,
		},
		{
			name: "Test failed entry",
			fields: fields{
				conn: db,
			},
			args: args{article: models.Article{
				Title:   "Exists",
				Content: "Once upon a time, Alohamora!",
				Author:  "J.K Rowling",
			}},
			wantID:  0,
			wantErr: true,
		},
		{
			name: "Test Successful Creation",
			fields: fields{
				conn: db,
			},
			args: args{article: models.Article{
				Title:   "Exists",
				Content: "Once upon a time, Alohamora!",
				Author:  "J.K Rowling",
			}},
			wantID:  1,
			wantErr: true,
		},
	}

	// Run tests
	for _, test := range tests {
		store := Article{conn: test.fields.conn}

		if test.name == "Test query error" {
			mock.ExpectQuery("SELECT (.+) FROM `article` WHERE .*").WillReturnError(errors.New("error trying to validate the article being added"))
			_, err = store.Create(test.args.article)
			assert.EqualError(t, err, "error trying to validate the article being added", "failed at: \"%v\"", test.name)
		}

		if test.name == "Test unique" {
			row := sqlmock.NewRows([]string{"id", "title", "content", "author"}).
				AddRow(1, "Exists", "Once upon a time, Alohamora!", "J.K Rowling")
			mock.ExpectQuery("SELECT (.+) FROM `article` WHERE .*").WillReturnRows(row)
			_, err = store.Create(test.args.article)
			assert.EqualErrorf(t, err, "error: record already exists", "failed at: \"%v\"", test.name)
		}

		if test.name == "Test failed entry" {
			// Pass empty records
			row := sqlmock.NewRows([]string{"id", "title", "content", "author"})
			mock.ExpectQuery("SELECT (.+) FROM `article` WHERE .*").WillReturnRows(row)

			// Fail insert
			mock.ExpectExec("^INSERT INTO `article`.*$").
				WithArgs(test.args.article.Title, test.args.article.Content, test.args.article.Author).
				WillReturnError(errors.New("error trying to insert a new entry"))

			_, err = store.Create(test.args.article)
			assert.EqualErrorf(t, err, "error trying to insert a new entry", "failed at: \"%v\"", test.name)
		}

		if test.name == "Test Successful Creation" {
			// Pass empty records
			row := sqlmock.NewRows([]string{"id", "title", "content", "author"})
			mock.ExpectQuery("SELECT (.+) FROM `article` WHERE .*").WillReturnRows(row)

			// Pass insert
			mock.ExpectExec("^INSERT INTO `article`.*$").
				WithArgs(test.args.article.Title, test.args.article.Content, test.args.article.Author).
				WillReturnResult(sqlmock.NewResult(1, 1))

			res, err := store.Create(test.args.article)
			if err != nil {
				assert.EqualErrorf(t, err, "error trying to insert a new entry", "failed at: \"%v\"", test.name)
			}
			assert.Equalf(t, test.wantID, res.Id, "failed at: \"%v\"", test.name)
		}
	}
}
